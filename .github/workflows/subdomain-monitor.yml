name: Subdomain Monitor (orgs → Discord + Nuclei Scan)

permissions:
  contents: write        # allows pushing commits, updating files
  id-token: write        # optional if you use OIDC (not needed for push)
  actions: read          # required to download artifacts between jobs

on:
  schedule:
    - cron: "0 */6 * * *"   # run every 6 hours
  workflow_dispatch:        # allow manual runs

jobs:
  monitor:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        org: [ "bitdefender", "telekom" ]

    env:
      # default ports for httpx-pd
      HTTPX_PORTS: "80,443,8080,8000,8888,8443,9443"

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0

      - name: Ensure directories exist
        run: |
          mkdir -p data/wildcards data/current data/previous data/new

      - name: Copy wildcards into working file
        run: |
          cp data/wildcards/${{ matrix.org }}.txt wildcards.txt

      - name: Install OS deps & unzip tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y unzip wget python3-pip jq

      - name: Setup Go (for projectdiscovery & tomnomnom tools)
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"

      - name: Install required Go tools and pip httpx
        run: |
          export PATH=$PATH:$HOME/go/bin
          go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest
          go install -v github.com/projectdiscovery/chaos-client/cmd/chaos@latest
          go install -v github.com/tomnomnom/anew@latest
          go install -v github.com/tomnomnom/assetfinder@latest
          pip3 install 'httpx[cli]' || true

      - name: Install findomain (binary)
        run: |
          curl -L -o findomain.zip "https://github.com/findomain/findomain/releases/latest/download/findomain-linux-i386.zip"
          unzip -o findomain.zip
          chmod +x findomain
          sudo mv findomain /usr/bin/findomain || sudo mv findomain /usr/local/bin/findomain
          rm -f findomain.zip

      - name: Install httpx (ProjectDiscovery linux_amd64) and move to httpx-pd
        run: |
          echo "[*] Downloading latest httpx release..."
          URL=$(curl -s https://api.github.com/repos/projectdiscovery/httpx/releases/latest \
            | grep "browser_download_url.*linux_amd64.zip" \
            | cut -d '"' -f 4)
          wget -q "$URL" -O httpx_latest.zip
          unzip -o httpx_latest.zip
          chmod +x httpx
          sudo mv httpx /usr/local/bin/httpx-pd
          rm -f httpx_latest.zip LICENSE.md README.md 2>/dev/null || true
          echo "[+] httpx-pd ready"

      - name: Export PDCP API key (robust)
        run: |
          if [ -n "${{ secrets.PDCP_API_KEY }}" ]; then
            echo "PDCP_API_KEY=${{ secrets.PDCP_API_KEY }}" >> $GITHUB_ENV
            echo "PDCP_API_KEY exported"
          else
            echo "PDCP_API_KEY not set — skipping chaos client"
          fi

      - name: Run subdomain enumeration pipeline
        id: enum
        run: |
              set -eux
              ORG=${{ matrix.org }}
              TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
              CUR_DIR="data/current/${ORG}"
              mkdir -p "$CUR_DIR"
    
              # run subfinder
              subfinder -silent -all -recursive -t 200 -dL wildcards.txt -o "$CUR_DIR/subfinder.txt" || true

              # findomain
              findomain -quiet -f wildcards.txt -oL "$CUR_DIR/findomain.txt" || true

              # assetfinder
              cat wildcards.txt | xargs -n1 -I {} bash -c "assetfinder --subs-only {} >> $CUR_DIR/assetfinder.txt || true"

              # export chaos key and run chaos
              export PDCP_API_KEY=907560e1-54a0-452e-a6db-3c21fecc2288
              echo "PDCP_API_KEY exported"
              chaos -dL wildcards.txt -silent -o "$CUR_DIR/chaos.txt" || true
  
              # subenum (run after chaos)
              if [ ! -d "SubEnum" ]; then
                git clone https://github.com/bing0o/SubEnum.git
                cd SubEnum
                chmod +x setup.sh
                ./setup.sh
                cd ..
              fi
              ./SubEnum/subenum.sh -l wildcards.txt -u wayback,crt,abuseipdb,Amass -o "$CUR_DIR/subenum.txt" || true

              # merge & dedupe results
              cat "$CUR_DIR"/*.txt 2>/dev/null | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | tr '[:upper:]' '[:lower:]' | sort -u > "$CUR_DIR/candidates.txt" || true

              # exclude reverse wildcard (telekom specific)
              if [ "$ORG" = "telekom" ]; then
                grep -v -E "reverse\.open-telekom-cloud\.com$" "$CUR_DIR/candidates.txt" > "$CUR_DIR/tmp.txt" || true
                mv "$CUR_DIR/tmp.txt" "$CUR_DIR/candidates.txt"
              fi

              # exclude out-of-scope subdomains for bitdefender
              if [ "$ORG" = "bitdefender" ]; then
                grep -v -E "(lsems\.gravityzone|ssems\.gravityzone|community|resellerportal|stats|sstats|brand|partner-marketing|businessinsights|businessemail|businessresources|oemhub|oemresources|crp|telcosuccess|demo)\.bitdefender\.com$" "$CUR_DIR/candidates.txt" > "$CUR_DIR/tmp.txt" || true
                mv "$CUR_DIR/tmp.txt" "$CUR_DIR/candidates.txt"
              fi

              echo "candidates saved to $CUR_DIR/candidates.txt"
              wc -l "$CUR_DIR/candidates.txt" || true
              echo "CANDIDATES=$CUR_DIR/candidates.txt" >> $GITHUB_OUTPUT

      - name: Probe live subdomains with httpx-pd
        id: probe
        run: |
          set -eux
          ORG=${{ matrix.org }}
          CUR="data/current/${ORG}/candidates.txt"
          LIVE="data/current/${ORG}/live.txt"
          touch $LIVE
          if [ -s "$CUR" ]; then
            cat "$CUR" | sed '/^\s*$/d' | httpx-pd -ports $HTTPX_PORTS -threads 200 -silent -o "$LIVE" || true
            # *** UPDATE 1: Strip ports to de-duplicate subdomains found on multiple ports ***
            sed -i 's/:.*//' "$LIVE"
          else
            echo "[!] no candidates"
          fi
          echo "LIVE=$LIVE" >> $GITHUB_OUTPUT
          wc -l "$LIVE" || true

      - name: Compare with previous and generate new list
        id: compare
        run: |
          set -eux
          ORG=${{ matrix.org }}
          PREV="data/previous/${ORG}.txt"
          CUR="data/current/${ORG}/live.txt"
          NEW_FILE="data/new/${ORG}-${GITHUB_RUN_ID}.txt"
          
          # Create previous file if it doesn't exist
          if [ ! -f "$PREV" ]; then
            touch "$PREV"
          fi
          
          # differences: lines in CUR but not in PREV
          comm -13 <(sort "$PREV") <(sort "$CUR") > "$NEW_FILE" || true
          # cleanup blank lines
          sed -i '/^\s*$/d' "$NEW_FILE" || true
          NEW_COUNT=$(wc -l < "$NEW_FILE" || echo 0)
          echo "NEW_FILE=$NEW_FILE" >> $GITHUB_OUTPUT
          echo "NEW_COUNT=$NEW_COUNT" >> $GITHUB_OUTPUT
          echo "NEW_COUNT=$NEW_COUNT"
          if [ "$NEW_COUNT" -eq 0 ]; then
            echo "No new live subdomains found."
          else
            echo "Found $NEW_COUNT new live subdomains"
            head -n 50 "$NEW_FILE" || true
          fi

      - name: Commit new results & update previous (if any)
        run: |
          set -eux
          ORG=${{ matrix.org }}
          PREV="data/previous/${ORG}.txt"
          CUR="data/current/${ORG}/live.txt"
          git config user.name "subdomain-bot"
          git config user.email "bot@example.com"
          
          # Pull latest changes before making our own
          git pull --rebase origin main || true
          
          # Always update the previous file with current results for the next run
          cp "$CUR" "$PREV"
          git add "$PREV"
          
          # Only add and commit new file if there are new subdomains
          if [ -s "data/new/${ORG}-${GITHUB_RUN_ID}.txt" ]; then
            git add "data/new/${ORG}-${GITHUB_RUN_ID}.txt"
            git commit -m "Update ${ORG} live subdomains - run ${GITHUB_RUN_ID}" || true
          else
            git commit -m "Update ${ORG} previous list - run ${GITHUB_RUN_ID}" || true
          fi
          git push || echo "Push failed; ensure repository has write permissions for the action"

      - name: Post new subdomains to Discord (embed, batched)
        if: steps.compare.outputs.NEW_COUNT != '' && steps.compare.outputs.NEW_COUNT != '0'
        run: |
          set -eux
          ORG=${{ matrix.org }}
          NEW_FILE="${{ steps.compare.outputs.NEW_FILE }}"
          COUNT=${{ steps.compare.outputs.NEW_COUNT }}
          # pick the webhook depending on org
          if [ "$ORG" = "bitdefender" ]; then
            WEBHOOK="${{ secrets.DISCORD_WEBHOOK_BITDEFENDER }}"
          else
            WEBHOOK="${{ secrets.DISCORD_WEBHOOK_TELEKOM }}"
          fi
          # build items (limit to 15)
          ITEMS_TEXT=$(head -n 15 "$NEW_FILE" | sed -z 's/\n/\\n/g' | sed 's/"/\\"/g')
          DESCRIPTION="New live subdomains: ${COUNT}. Showing first 15. See repo for full list."
          EMBED=$(jq -n --arg title "New live subdomains — ${ORG} (${COUNT} new)" \
                --arg desc "$DESCRIPTION" \
                --arg items "$(head -n 15 "$NEW_FILE" | paste -s -d'\n' - | sed 's/"/\\"/g')" \
                '{
                  "embeds":[
                    {
                      "title":$title,
                      "description":$desc,
                      "fields":[ {"name":"New (first 15)","value":$items,"inline":false} ],
                      "footer":{"text":"Run via GitHub Actions"} 
                    }
                  ]
                }')
          # simple rate-limit backoff (avoid bursts)
          sleep $(( (RANDOM % 3) + 1 ))
          curl -s -H "Content-Type: application/json" -d "$EMBED" "$WEBHOOK" || echo "Discord post failed"

      - name: Upload new file as artifact for Nuclei scan
        if: steps.compare.outputs.NEW_COUNT != '' && steps.compare.outputs.NEW_COUNT != '0'
        uses: actions/upload-artifact@v4
        with:
          name: new-${{ matrix.org }}-subdomains
          path: ${{ steps.compare.outputs.NEW_FILE }}
          retention-days: 1 # Keep artifact for 1 day, enough for the next Nuclei scan

  # *** UPDATE 2 & 3: New job for Nuclei scanning ***
  nuclei-scan:
    name: Nuclei Vulnerability Scan
    needs: monitor
    runs-on: ubuntu-latest
    strategy:
      matrix:
        org: [ "bitdefender", "telekom" ]

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.21"

      - name: Install Nuclei
        run: go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest

      # *** UPDATE 3: Check if it's the right time to run (every 12 hours) ***
      - name: Check execution time
        id: timecheck
        run: |
          HOUR=$(date +%H)
          # Run only at 00:00 or 12:00 UTC
          if [[ "$HOUR" == "00" || "$HOUR" == "12" ]]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "It's time for the Nuclei scan."
          else
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "Skipping Nuclei scan. Next run at 00:00 or 12:00 UTC."
          fi

      - name: Download new subdomains list
        if: steps.timecheck.outputs.should_run == 'true'
        uses: actions/download-artifact@v4
        with:
          name: new-${{ matrix.org }}-subdomains
          path: ./
          # The artifact is uploaded by the 'monitor' job from the same run
          run-id: ${{ github.run_id }}

      - name: Run Nuclei on new subdomains
        id: nuclei
        if: steps.timecheck.outputs.should_run == 'true'
        run: |
          set -eux
          NEW_FILE="new-${{ matrix.org }}-${GITHUB_RUN_ID}.txt"
          if [ ! -s "$NEW_FILE" ]; then
            echo "No new subdomains file found to scan. Skipping."
            echo "scan_results=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "Updating Nuclei templates..."
          nuclei -update-templates

          echo "Running Nuclei scan on $NEW_FILE..."
          # Using -json for easier parsing, -o for output file
          nuclei -l "$NEW_FILE" -tags http -es info -mhe 5 -stats -json \
            -H "X-Forwarded-For: 127.0.0.1" \
            -H "X-Forwarded-Host: 127.0.0.1" \
            -H "X-Forwarded: 127.0.0.1" \
            -H "Forwarded-For: 127.0.0.1" \
            -o nuclei_results.txt

          if [ -s "nuclei_results.txt" ]; then
            echo "scan_results=true" >> $GITHUB_OUTPUT
            echo "Nuclei found findings."
          else
            echo "scan_results=false" >> $GITHUB_OUTPUT
            echo "Nuclei found no findings."
          fi

      # *** UPDATE 4: Send Nuclei results to Discord ***
      - name: Post Nuclei results to Discord
        if: steps.nuclei.outputs.scan_results == 'true'
        run: |
          set -eux
          ORG=${{ matrix.org }}
          # pick the webhook depending on org
          if [ "$ORG" = "bitdefender" ]; then
            WEBHOOK="${{ secrets.DISCORD_WEBHOOK_BITDEFENDER }}"
          else
            WEBHOOK="${{ secrets.DISCORD_WEBHOOK_TELEKOM }}"
          fi
          
          # Format the JSON output into a readable text block for Discord
          # Limit to first 10 findings to avoid message size limits
          FINDINGS=$(head -n 10 nuclei_results.txt | jq -r '"\(.templateID): \(.host) (\(.info.name))"' | paste -s -d'\n' -)
          COUNT=$(wc -l < nuclei_results.txt)
          
          DESCRIPTION="Nuclei scan on new subdomains found **${COUNT}** potential issues. Showing first 10."
          
          EMBED=$(jq -n --arg title "🚨 Nuclei Findings for ${ORG}" \
                --arg desc "$DESCRIPTION" \
                --arg findings "$FINDINGS" \
                '{
                  "embeds":[
                    {
                      "title":$title,
                      "description":$desc,
                      "color": 16711680, # Red color
                      "fields":[ {"name":"Findings","value":"```'"$FINDINGS"'```","inline":false} ],
                      "footer":{"text":"Run via GitHub Actions"} 
                    }
                  ]
                }')
          
          curl -s -H "Content-Type: application/json" -X POST -d "$EMBED" "$WEBHOOK" || echo "Discord post failed"
